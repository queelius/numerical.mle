[{"path":"https://queelius.github.io/numerical.mle/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 algebraic.mle authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://queelius.github.io/numerical.mle/articles/unknow_dgp.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Fitting models to unknown DGPs","text":"interested generative process gave rise data observed. real world, DGPs quite complex, settle simpler models analytical tractability. , usually assume: sample ..d. way evaluating quality model. way choosing models. Since simulation, know underlying DGP (data generating process). ’s just \\[     T_i = W_i + \\epsilon_i \\] \\[     W_i \\sim \\operatorname{weibull}(k,\\lambda) \\] \\[     \\epsilon_i \\sim \\operatorname{normal}(0,\\sigma). \\] real world, know DGP. study, assume either \\(T_1,\\ldots,T_n\\) comes Weibull Normal. Clearly, true DGF bit complicated still simple compared realistic DGP. , process parametrically modeling observed data may take following steps: Visualize data, e.g., plot histogram data. Guess parametric distribution (components) might fit observed data system lifetime. Use statistical test goodness--fit. Repeat steps 2 3 measure goodness fit satisfactory.","code":""},{"path":"https://queelius.github.io/numerical.mle/articles/unknow_dgp.html","id":"simulation-parameters-and-generation","dir":"Articles","previous_headings":"","what":"Simulation parameters and generation","title":"Fitting models to unknown DGPs","text":"simulation parameters given : generate data following R code: elements sample given :","code":"library(tibble) library(stats)  sim.n <- 27 sim.err.sd <- 0.05 sim.shape <- 20 sim.scale <- 3 sim.theta = c(sim.shape,sim.scale) set.seed(142334) sim.df <- tibble(lifetime=   rweibull(n=sim.n, shape=sim.shape, scale=sim.scale) +   rnorm(n=sim.n, mean=0, sd=sim.err.sd)) #> # A tibble: 6 × 1 #>   lifetime #>      <dbl> #> 1     2.91 #> 2     2.73 #> 3     3.09 #> 4     2.91 #> 5     3.20 #> 6     2.94"},{"path":"https://queelius.github.io/numerical.mle/articles/unknow_dgp.html","id":"visualizing-the-data","dir":"Articles","previous_headings":"","what":"Visualizing the data","title":"Fitting models to unknown DGPs","text":"Visualizing data good first step analysis data. data univariate bivariate, can plot histogram data pretty easily (’s multivariate, can plot marginal distributions data). show histogram simulated data :","code":""},{"path":"https://queelius.github.io/numerical.mle/articles/unknow_dgp.html","id":"parametrically-modeling-the-data","dir":"Articles","previous_headings":"","what":"Parametrically modeling the data","title":"Fitting models to unknown DGPs","text":"sample, might conclude? can difficult problem. case, know simulated data drawn distribution \\(T_i = W_i + \\epsilon_i\\) \\[   W_i \\sim \\operatorname{weibull}(\\lambda = 20,                                 k = 3) \\] \\[   \\epsilon_i \\sim \\operatorname{normal}(\\mu=0,\\sigma=0.05). \\] However, real-world data sets, know distribution. , let us suppose know true distribution data. interested , say, prediction, sufficiently large sample, use non-parametric methods “let data speak .” However, interested inference (e.g., explaining data) sample small, usually need make assumptions data. case, assume data drawn parametric distribution. many well-known, named parametric distributions, e.g., Pareto, Weibull, Normal, name . experience, seems like Weibull normal might good fits data. However, note since normal distribution permits negative values realized, may appropriate choice. Still, since approximations anyway, may big deal.","code":""},{"path":"https://queelius.github.io/numerical.mle/articles/unknow_dgp.html","id":"maximum-likelihood-estimation","dir":"Articles","previous_headings":"","what":"Maximum likelihood estimation","title":"Fitting models to unknown DGPs","text":"First, let us fit Weibull distribution choosing appropriate shape \\(\\lambda\\) scale \\(k\\) parameters using maximum likelihood estimator. find MLE \\(\\theta = (\\lambda,k)'\\), need log-likelihood function, given following R code: MLE point \\((\\hat k,\\hat\\lambda)'\\) maximum loglikelihood function, loglike, support parameters. Typically, closed solutions aren’t possible, normally use sort iterative technique. don’t go details , normally local search method, like Newton-Raphson (finds value makes gradient loglikelihood function zero) used. However, local methods – local – need good starting point. example Newton-raphson code, use since efficient easy understand: use efficient algorithm compute log-likelihood function Weibull distribution. code given :","code":"loglike <- function(theta) sum(dweibull(   sim.df$lifetime, shape=theta[1], scale=theta[2], log=T)) # f is the function we want to find the root of # Jf is the jocabian of f # x0 is the starting point newton_raphson <- function(f, df, x0) {   eta <- 1 # learning rate, not too large to avoid overshooting            # not too small to avoid slow convergence   eps <- 1e-3 # close enough to zero to stop     repeat   {     fx <- f(x0)        # new function value     if (max(abs(fx)) < eps) break # f(x) is close enough to zero     J <- Jf(x0)        # jacobian     d <- solve(J,fx)   # newton-raphson direction (pointing uphill)     x0 <- x0 + eta * d # newton-raphson update (going uphill)   }   x0 } library(algebraic.mle) #>  #> Attaching package: 'algebraic.mle' #> The following object is masked _by_ '.GlobalEnv': #>  #>     loglike ll.wei <- weibull_shape_scale_loglike(sim.df$lifetime)"},{"path":"https://queelius.github.io/numerical.mle/articles/unknow_dgp.html","id":"numerical-considerations","dir":"Articles","previous_headings":"Maximum likelihood estimation","what":"Numerical considerations","title":"Fitting models to unknown DGPs","text":"algebraic.mle package, provide precise efficient local iterative algorithm, mle_weibull_shape_scale, finding MLE Weibull distribution. local search method, needs good starting point shape parameter \\(k\\) close MLE, otherwise may fail converge MLE. find good starting point, use global search method, Simulated Annealing, implemented sim_anneal function. code finding good starting point: Let’s take look plots simulated annealing algorithm: first plot, see history log-likelihood values algorithm progresses. second plot shows path algorithm explores support parameters. third plot shows shape parameter, \\(k\\), algorithm progresses. red line true value \\(k\\). starting point hand, find MLE : function, mle_weibull_shape_scale, returns mle object, API provides number conventient methods, estimating variance-covariance matrix, confidence intervals, bias, . ’s code print summary MLE: Let’s normal distribution. use mle_normal_mu_var function algebraic.mle package: Let’s plot pdfs Weibull normal distributions: purple, true density (DGP). red, Weibull density. green, normal density. plot, ’s hard tell distribution better fit DGP. Interestingly, tails true distribution seem bit heavier tails Weibull Normal. may suggest heavier-tailed model may better fit, lognormal distribution, pursue . choose Weibull Normal distributions? discuss next section.","code":"# find a good starting position start <- sim_anneal(   f=ll.wei,   x0=sim.theta,   options=list(     t_init=100,     t_end=1e-4,     alpha=0.99,     iter_per_temp=200,     sup=function(theta) all(theta > 0),     trace=TRUE)) k0 <- start$argmax[1] cat(\"initial guess for k0 =\",k0,\"\\n\") #> initial guess for k0 = 20.06285 library(algebraic.mle) mle.wei <- mle_weibull_shape_scale(sim.df$lifetime, k0=k0) summary(mle.wei) #> Maximum likelihood estimator of type mle_weibull_shape_scale is normally distributed. #> The estimates of the parameters are given by: #>     shape     scale  #> 20.090236  2.941726  #> The standard error is  3.719537 0.03642942 . #> The asymptotic 95% confidence interval of the parameters are given by: #>            2.5%     97.5% #> shape 13.972143 26.208329 #> scale  2.881805  3.001647 #> The MSE of the estimator is  13.83628 . #> The log-likelihood is  10.99502 . #> The AIC is  -17.99005 . mle.norm <- mle_normal_mu_var(sim.df$lifetime) summary(mle.norm) #> Maximum likelihood estimator of type mle_normal_mu_var is normally distributed. #> The estimates of the parameters are given by: #>         mu        var  #> 2.86797534 0.02500757  #> The standard error is  0.03043364 0.006806199 . #> The asymptotic 95% confidence interval of the parameters are given by: #>           2.5%      97.5% #> mu  2.81791646 2.91803422 #> var 0.01381237 0.03620277 #> The MSE of the estimator is  0.0009733886 . #> The log-likelihood is  11.48444 . #> The AIC is  -18.96889 ."},{"path":"https://queelius.github.io/numerical.mle/articles/unknow_dgp.html","id":"goodness-of-fit","dir":"Articles","previous_headings":"","what":"Goodness of fit","title":"Fitting models to unknown DGPs","text":"fitting model data precisely capture generative model \\(W\\). , good fit ? conduct goodness fit test, \\[\\begin{align}   H_0 &: \\text{data compatible Weibull distribution}\\\\   H_A &: \\text{data compatible Weibull distribution}. \\end{align}\\] perform test, use Cramer-von Mises test. test based Cramer-von Mises statistic, measure distance empirical distribution function data distribution function model. Cramer-von Mises statistic given \\[   \\hat D_n^2 = \\frac{1}{n}\\sum_{=1}^n \\left(\\hat F_n(x_i) - F(x_i)\\right)^2 \\] \\(\\hat F_n\\) empirical distribution function data \\(F\\) distribution function model. Looking \\(p\\)-value, see data compatible Weibull distribution. Now, let’s normal distribution: compatible data. However, Weibull distribution larger \\(p\\)-value, may suggest better fit. also AIC measure goodness fit. AIC given \\[   \\text{AIC} = -2\\log L + 2k, \\] \\(L\\) likelihood model \\(k\\) number parameters model. AIC measure tradeoff goodness fit complexity model. lower AIC value indicates better fit. Thus, according measure, Weibull distribution better fit.","code":"cramer.test <- function(obs.dat,ref.dat) {   stat <- CDFt::CramerVonMisesTwoSamples(obs.dat,ref.dat)   list(p.value=exp(-stat)/6.0,        cramer.stat=stat,        obs.size=length(obs.dat),        ref.size=length(ref.dat)) }  wei.shape <- point(mle.wei)[1] wei.scale <- point(mle.wei)[2] ref.dat <- rweibull(1000000,shape=wei.shape,scale=wei.scale) cramer.test(sim.df$lifetime,ref.dat) #> $p.value #> [1] 0.1632591 #>  #> $cramer.stat #> [1] 0.02065722 #>  #> $obs.size #> [1] 27 #>  #> $ref.size #> [1] 1000000 norm.mu <- point(mle.norm)[1] norm.var <- point(mle.norm)[2] ref.dat <- rnorm(1000000,mean=norm.mu,sd=sqrt(norm.var)) cramer.test(sim.df$lifetime,ref.dat) #> $p.value #> [1] 0.1602598 #>  #> $cramer.stat #> [1] 0.03919976 #>  #> $obs.size #> [1] 27 #>  #> $ref.size #> [1] 1000000 aic(mle.wei) #> [1] -17.99005 aic(mle.norm) #>       var  #> -18.96889"},{"path":"https://queelius.github.io/numerical.mle/articles/unknow_dgp.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Fitting models to unknown DGPs","text":"post, shown fit Weibull Normal distributions simulated dataset whose true distribution, known, common name. shown compare two models using Cramer-von Mises test AIC measure goodness fit. came definitive conclusion model better, Weibull distribution larger \\(p\\)-value Cramer-von Mises test, lower AIC value, serves evidence better fit. saw true DGP visually different Weibull normal distributions. Notably, DGP longer tails , suggesting even better fit may long-tail distribution like log-normal Pareto distribution.","code":"# store sequence of steps in gradient ascent/newton raphson and plot the points # overlay it with loglike library(tidyverse) library(md.tools) library(stats)  theta <- c(100,2) n <- 17 data <- rweibull(n,shape=theta[1],scale=theta[2]) loglik <- weibull_shape_scale_loglike(data) scr <- weibull_shape_scale_score(data) nfo <- weibull_shape_scale_fim(data)  theta0 <- c(5,15)  sup.weibull <- function(theta) {     all(theta > 0) }  theta.start <- sim_anneal(     f=loglik,     x0=theta0,     options=list(         t_init=100,         t_end=1e-4,         alpha=0.99,         iter_per_temp=200,         sup=sup.weibull,         debug=FALSE,         trace=TRUE))  logliks <- apply(theta.start$path,1,loglik) plot(logliks,type=\"l\",xlab=\"iteration\",ylab=\"log-likelihood\")  theta.mle <- mle_weibull_shape_scale(     data,     k0=theta.start$argmax[1],     eps=1e-10)  theta.nr <- mle_newton_raphson(     ll=loglik,     theta0=theta.start$argmax,     score=scr,     info=nfo,     options=list(         sup=sup.weibull,         rel_tol=1e-12,         eta=.1,         trace=TRUE))  trace.ll <- apply(theta.nr$trace,1,loglik) plot(trace.ll,type=\"l\")  point(theta.nr) mle_local_search  theta.optim <- mle_optim(optim(     par=theta.start$argmax,     fn=loglik,     gr=scr,           hessian=TRUE,     control=list(fnscale=-1,reltol=1e-16, maxit=2000000)))"},{"path":"https://queelius.github.io/numerical.mle/articles/unknow_dgp.html","id":"pis","dir":"Articles","previous_headings":"","what":"PIs","title":"Fitting models to unknown DGPs","text":"","code":"n <- 100 theta <- c(4,2) x <- rnorm(n,mean=theta[1],sd=sqrt(theta[2])) head(x,n=4) hist(x) theta.hat <- mle_normal_mu_var(x) summary(theta.hat) point(theta.hat) fim(theta.hat) vcov(theta.hat) confint(theta.hat) bias(theta.hat,theta) bias(theta.hat) mse(theta.hat)        # estimate of MSE mse(theta.hat,theta)  # true MSE  mle_solver <- function(data, ind)     point(mle_normal_mu_var(data[ind])) R <- 100000 # number of bootstrap replicates  theta.boot <- mle_boot(mle_solver, x, R, parallel=\"multicore\", ncpus=4) bias(theta.boot) bias(theta.hat)  samplr <- function(n=1,theta) rnorm(n,theta[1],theta[2]) pred(x=theta.hat, samp=samplr)"},{"path":"https://queelius.github.io/numerical.mle/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Alexander Towell. Author, maintainer.","code":""},{"path":"https://queelius.github.io/numerical.mle/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Towell (2023). numerical.mle: Numerical maximum likelihood estimation. https://github.com/queelius/numerical.mle, https://queelius.github.io/numerical.mle/.","code":"@Manual{,   title = {numerical.mle: Numerical maximum likelihood estimation},   author = {Alexander Towell},   year = {2023},   note = {https://github.com/queelius/numerical.mle, https://queelius.github.io/numerical.mle/}, }"},{"path":"https://queelius.github.io/numerical.mle/index.html","id":"r-package-numericalmle","dir":"","previous_headings":"","what":"Numerical maximum likelihood estimation","title":"Numerical maximum likelihood estimation","text":"set numeric MLE solvers. early alpha. just started project ready use yet. just took bunch numerical code algebraic.mle put separate package. adding numerical solvers examples future. code probably even work yet, since haven’t tested .","code":""},{"path":"https://queelius.github.io/numerical.mle/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Numerical maximum likelihood estimation","text":"can install numerical.mle GitHub :","code":"install.packages(\"devtools\") devtools::install_github(\"queelius/numerical.mle\")"},{"path":"https://queelius.github.io/numerical.mle/index.html","id":"api","dir":"","previous_headings":"","what":"API","title":"Numerical maximum likelihood estimation","text":"set methods fitting log-likelihood functions data. provide various adapters log-likelihood functions, including penalty adapters (constrained MLEs) transformation adapters (transformed MLEs). object representing fitted model type mle object, maximum likelihood estimator model respect observed data. use R package purpose. (See ). API mostly consists generic methods implementations various mle type objects. full list functions, see function reference numerical.mle.","code":""},{"path":[]},{"path":"https://queelius.github.io/numerical.mle/index.html","id":"fitting-a-linear-regression-model","dir":"","previous_headings":"Examples","what":"Fitting a linear regression model","title":"Numerical maximum likelihood estimation","text":"","code":"library(numerical.mle) library(algebraic.mle)"},{"path":"https://queelius.github.io/numerical.mle/reference/is_converged.html","id":null,"dir":"Reference","previous_headings":"","what":"is_converged — is_converged","title":"is_converged — is_converged","text":"Function determine whether `mle_numerical` object converged.","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/is_converged.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"is_converged — is_converged","text":"","code":"is_converged(x)"},{"path":"https://queelius.github.io/numerical.mle/reference/is_converged.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"is_converged — is_converged","text":"x `mle` object ... additional arguments pass","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/is_mle_numerical.html","id":null,"dir":"Reference","previous_headings":"","what":"is_mle_numerical — is_mle_numerical","title":"is_mle_numerical — is_mle_numerical","text":"Function determine whether object `x` type `mle_numerical`.","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/is_mle_numerical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"is_mle_numerical — is_mle_numerical","text":"","code":"is_mle_numerical(x)"},{"path":"https://queelius.github.io/numerical.mle/reference/is_mle_numerical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"is_mle_numerical — is_mle_numerical","text":"x `mle` object ... additional arguments pass","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/mle_gradient_ascent.html","id":null,"dir":"Reference","previous_headings":"","what":"mle_gradient_ascent — mle_gradient_ascent","title":"mle_gradient_ascent — mle_gradient_ascent","text":"MLE method using gradient ascent","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/mle_gradient_ascent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"mle_gradient_ascent — mle_gradient_ascent","text":"","code":"mle_gradient_ascent(theta0, score, options)"},{"path":"https://queelius.github.io/numerical.mle/reference/mle_gradient_ascent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"mle_gradient_ascent — mle_gradient_ascent","text":"theta0 initial guess MLE score score function, gradient log-likelihood","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/mle_gradient_ascent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"mle_gradient_ascent — mle_gradient_ascent","text":"object class `mle_gradient_ascent`, `mle` object","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/mle_grid_search.html","id":null,"dir":"Reference","previous_headings":"","what":"mle_grid_search — mle_grid_search","title":"mle_grid_search — mle_grid_search","text":"MLE method using grid search","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/mle_grid_search.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"mle_grid_search — mle_grid_search","text":"","code":"mle_grid_search(loglike, options)"},{"path":"https://queelius.github.io/numerical.mle/reference/mle_local_search.html","id":null,"dir":"Reference","previous_headings":"","what":"mle_local_search — mle_local_search","title":"mle_local_search — mle_local_search","text":"Performs local search find MLE, assuming MLE interior point support initial guess `theta0` near MLE provided. Use global search method like `sim_anneal` find good initial guess.","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/mle_local_search.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"mle_local_search — mle_local_search","text":"","code":"mle_local_search(dir, theta0, loglike = NULL, options = list())"},{"path":"https://queelius.github.io/numerical.mle/reference/mle_local_search.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"mle_local_search — mle_local_search","text":"dir function, promising direction function theta0 numeric, initial guess options list, options local search, see function description.","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/mle_local_search.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"mle_local_search — mle_local_search","text":"`mle` object additional attributes `iter` `converged`         optionally `path` `trace` TRUE.","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/mle_local_search.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"mle_local_search — mle_local_search","text":"mle_local_search(): options","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/mle_local_search.html","id":"fields","dir":"Reference","previous_headings":"","what":"Fields","title":"mle_local_search — mle_local_search","text":"sup function, domain support log-likelihood eta numeric, learning rate, defaults 1 max_iter integer, maximum number iterations, defaults 1000 max_iter_ls integer, maximum number iterations line search, defaults 1000 abs_tol numeric, tolerance convergence, defaults NULL (use rel_tol instead) rel_tol numeric, relative tolerance convergence, defaults 1e-5 r numeric, backtracking line search parameter, defaults 0.5 proj function, projection function enforce domain support norm function, distance measure convergence checks, defaults infinity norm. debug logical, output debugging information TRUE; default FALSE trace logical, TRUE store path search `path` attribute output; default FALSE line_search logical, TRUE, perform line search; default TRUE case, learning rate `eta` refers maximum step size can taken per iteration. debug_freq integer, frequency debug output, defaults 1","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/mle_newton_raphson.html","id":null,"dir":"Reference","previous_headings":"","what":"mle_newton_raphson — mle_newton_raphson","title":"mle_newton_raphson — mle_newton_raphson","text":"Find MLE using Newton-Raphson method.","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/mle_newton_raphson.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"mle_newton_raphson — mle_newton_raphson","text":"","code":"mle_newton_raphson(score, fim, theta0, inverted = FALSE, options = list())"},{"path":"https://queelius.github.io/numerical.mle/reference/mle_newton_raphson.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"mle_newton_raphson — mle_newton_raphson","text":"score score Function, gradient log-likelihood fim FIM function theta0 initial guess MLE inverted logical, TRUE `fim` covariance instead FIM","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/mle_newton_raphson.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"mle_newton_raphson — mle_newton_raphson","text":"object class `mle_newton_raphson`, `mle` object","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/mle_numerical.html","id":null,"dir":"Reference","previous_headings":"","what":"mle_numerical — mle_numerical","title":"mle_numerical — mle_numerical","text":"constructor mle_numerical class.","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/mle_numerical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"mle_numerical — mle_numerical","text":"","code":"mle_numerical(theta.hat, loglike, score, info, sigma, iter, converged)"},{"path":"https://queelius.github.io/numerical.mle/reference/mle_optim.html","id":null,"dir":"Reference","previous_headings":"","what":"mle_optim — mle_optim","title":"mle_optim — mle_optim","text":"function takes output `optim` turns `mle` object.","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/mle_optim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"mle_optim — mle_optim","text":"","code":"mle_optim(sol)"},{"path":"https://queelius.github.io/numerical.mle/reference/mle_optim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"mle_optim — mle_optim","text":"sol output `optim`","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/mle_optim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"mle_optim — mle_optim","text":"`numerical_mle` object, specialized `optim` (stats package) solutions.","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/mle_random_restart.html","id":null,"dir":"Reference","previous_headings":"","what":"mle_random_restart — mle_random_restart","title":"mle_random_restart — mle_random_restart","text":"MLE method using random restart","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/mle_random_restart.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"mle_random_restart — mle_random_restart","text":"","code":"mle_random_restart(rtheta0, options)"},{"path":"https://queelius.github.io/numerical.mle/reference/mle_random_restart.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"mle_random_restart — mle_random_restart","text":"rtheta0 initial guess MLE distribution, defaults MVN wide variance","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/mle_random_restart.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"mle_random_restart — mle_random_restart","text":"interesting idea use random restarts find MLE. similar idea simulated annealing, instead using temperature parameter, just try bunch random starting try find MLE starting points using `mle_solver`. best MLE returned. reasonable `rtheta0` multivariate normal distribution wide variance. want explore entire parameter space. already candidate MLE `x`, can use sampling distribution MLE (MVN mean `point(x)` variance-covariance `vcov(x)`). generate random starting points close candidate MLE, may help us find better MLE.","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/mle_random_search.html","id":null,"dir":"Reference","previous_headings":"","what":"mle_random_search — mle_random_search","title":"mle_random_search — mle_random_search","text":"MLE method using random search","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/mle_random_search.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"mle_random_search — mle_random_search","text":"","code":"mle_random_search(rtheta, loglike, options)"},{"path":"https://queelius.github.io/numerical.mle/reference/mle_sim_anneal.html","id":null,"dir":"Reference","previous_headings":"","what":"mle_sim_anneal — mle_sim_anneal","title":"mle_sim_anneal — mle_sim_anneal","text":"function takes output `sim_anneal` turns `mle` object.","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/mle_sim_anneal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"mle_sim_anneal — mle_sim_anneal","text":"","code":"mle_sim_anneal(theta0, loglike = NULL, options = list())"},{"path":"https://queelius.github.io/numerical.mle/reference/mle_solve.html","id":null,"dir":"Reference","previous_headings":"","what":"mle_solve — mle_solve","title":"mle_solve — mle_solve","text":"Uses various functions algorithms find MLE.","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/mle_solve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"mle_solve — mle_solve","text":"","code":"mle_solve(options, theta0, method = c(\"optim\"), ...)"},{"path":"https://queelius.github.io/numerical.mle/reference/mle_solve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"mle_solve — mle_solve","text":"theta0 numeric vector, initial guess MLE","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/num_iterations.html","id":null,"dir":"Reference","previous_headings":"","what":"num_iterations — num_iterations","title":"num_iterations — num_iterations","text":"num_iterations","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/num_iterations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"num_iterations — num_iterations","text":"","code":"num_iterations(x)"},{"path":"https://queelius.github.io/numerical.mle/reference/num_iterations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"num_iterations — num_iterations","text":"x `mle` object ... additional arguments pass","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/num_iterations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"num_iterations — num_iterations","text":"number iterations used find MLE","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/num_iterations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"num_iterations — num_iterations","text":"","code":"loglike <- function(theta) {    -sum(dnorm(theta, mean = theta[1], sd = theta[2], log = TRUE)) } score <- function(theta) {   -numDeriv::grad(loglike, theta) } sol <- mle_gradient_raphson(theta0 = theta, score = score, loglike = loglike) #> Error in mle_gradient_raphson(theta0 = theta, score = score, loglike = loglike): could not find function \"mle_gradient_raphson\" num_iterations(sol) #> Error in is_mle_numerical(x): object 'sol' not found"},{"path":"https://queelius.github.io/numerical.mle/reference/numerical.mle.html","id":null,"dir":"Reference","previous_headings":"","what":"`numerical.mle`: A package for numerically solving maximum likelihood estimators\nfrom log-likelihood functions. — numerical.mle","title":"`numerical.mle`: A package for numerically solving maximum likelihood estimators\nfrom log-likelihood functions. — numerical.mle","text":"object representing fitted model type `mle` object, maximum likelihood estimator model respect observed data. use R package `algebraic.mle` represent objects.","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/penalize_loglike.html","id":null,"dir":"Reference","previous_headings":"","what":"loglikelihood constructor\npenalizes — penalize_loglike","title":"loglikelihood constructor\npenalizes — penalize_loglike","text":"loglikelihood constructor penalizes","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/penalize_loglike.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"loglikelihood constructor\npenalizes — penalize_loglike","text":"","code":"penalize_loglike(loglike, penalty, options)"},{"path":"https://queelius.github.io/numerical.mle/reference/sim_anneal.html","id":null,"dir":"Reference","previous_headings":"","what":"sim_anneal — sim_anneal","title":"sim_anneal — sim_anneal","text":"function implements simulated annealing algorithm, global optimization algorithm useful finding good starting point local optimization algorithm. return MLE object , good estimate MLE, gradient `f` evaluated solution close zero, assuming MLE interior domain `f`. However, since algorithm guided gradient information, sensitive gradient `f` instead seeks maximize `f`.","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/sim_anneal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"sim_anneal — sim_anneal","text":"","code":"sim_anneal(x0 = NULL, obj_fn = NULL, options = list(), ...)"},{"path":"https://queelius.github.io/numerical.mle/reference/sim_anneal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"sim_anneal — sim_anneal","text":"x0 Initial guess, default NULL (must specified options) obj_fn Objective function maximize, default NULL (must specified options) options List optional arguments ... Additional arguments may passed `options$neigh`","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/sim_anneal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"sim_anneal — sim_anneal","text":"list best solution (argmax) corresponding         objective function value (max), optionally path","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/sim_anneal.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"sim_anneal — sim_anneal","text":"sim_anneal(): options","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/sim_anneal.html","id":"fields","dir":"Reference","previous_headings":"","what":"Fields","title":"sim_anneal — sim_anneal","text":"t_init Initial temperature t_end Final temperature alpha Cooling factor iter_per_temp Number iterations per temperature max_iter Maximum number iterations, used instead t_end NULL, defaults NULL debug TRUE, print debugging information console trace TRUE, track history positions values sup Support function, returns TRUE x domain f neigh Neighborhood function, returns random neighbor x debug_freq Frequency debug output, defaults 10 obj_fn Objective function maximize, specified formal parameter `obj_fn` x0 Initial guess, specified formal parameter `x0`","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/stochastic_loglike.html","id":null,"dir":"Reference","previous_headings":"","what":"stochastic loglikelihood constructor\ngood for large datasets. if applied to a gradient ascent method, this\nwill perform stochastic gradient ascent. — stochastic_loglike","title":"stochastic loglikelihood constructor\ngood for large datasets. if applied to a gradient ascent method, this\nwill perform stochastic gradient ascent. — stochastic_loglike","text":"stochastic loglikelihood constructor good large datasets. applied gradient ascent method, perform stochastic gradient ascent.","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/stochastic_loglike.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"stochastic loglikelihood constructor\ngood for large datasets. if applied to a gradient ascent method, this\nwill perform stochastic gradient ascent. — stochastic_loglike","text":"","code":"stochastic_loglike(log.p, obs, options)"},{"path":"https://queelius.github.io/numerical.mle/reference/stochastic_loglike.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"stochastic loglikelihood constructor\ngood for large datasets. if applied to a gradient ascent method, this\nwill perform stochastic gradient ascent. — stochastic_loglike","text":"log.p log pdf (pmf) parametric model fit `obs` parameters. can also just proportional log pdf, since sometimes normalizing constant unknown hard compute. obs matrix, vector, data frame observations options list options","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/subdivide_region.html","id":null,"dir":"Reference","previous_headings":"","what":"subdivide_region — subdivide_region","title":"subdivide_region — subdivide_region","text":"subdivide_region","code":""},{"path":"https://queelius.github.io/numerical.mle/reference/subdivide_region.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"subdivide_region — subdivide_region","text":"","code":"subdivide_region(lower, upper, grid_size)"},{"path":"https://queelius.github.io/numerical.mle/reference/subdivide_region.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"subdivide_region — subdivide_region","text":"lower lower bounds parameter support (vector) upper upper bounds parameter support (vector) grid_size maximum size dimension hypercube makes grid","code":""}]
